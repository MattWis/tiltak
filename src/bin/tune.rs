use clap::{App, Arg, SubCommand};
use std::path::Path;
use taik::board::{NUM_POLICY_PARAMS, NUM_VALUE_PARAMS, POLICY_PARAMS_5S, VALUE_PARAMS_5S};
use taik::tune::{spsa, training};

fn main() {
    let app = App::new("Taik variable tuning")
        .version("0.1")
        .author("Morten Lohne")
        .subcommand(SubCommand::with_name("selfplay")
            .about("Tune value and policy constants by playing against itself. Will write the games to text files in the working directory."))
        .subcommand(SubCommand::with_name("selfplay-from-scratch")
                        .about("Tune value and policy constants from randomly initialized values by playing against itself. Will write the games to text files in the working directory."))
        .subcommand(SubCommand::with_name("value-from-file")
                .about("Tune value constants from randomly initialized values, using the given ptn file. Note that the ptn parser is completely broken, and will probably fail on any files not generated by this program itself.")
                .arg(Arg::with_name("file-name")
                    .index(1)
                    .required(true)
                    .value_name("games.ptn")))
        .subcommand(
            SubCommand::with_name("both-from-file")
                .about("Tune value and policy constants from randomly initialized values, using the given text file")
                .arg(Arg::with_name("value-file-name")
                    .index(1)
                    .required(true)
                    .value_name("games.ptn"))
                .arg(Arg::with_name("policy-file-name")
                    .index(2)
                    .required(true)
                    .value_name("move_scores.txt"))
        )
        .subcommand(SubCommand::with_name("spsa")
            .about("Tune exploration parameters using SPSA. Starting values are hard-coded.")
            .arg(Arg::with_name("book")
                .takes_value(true)
                .long("book")
                .help("Opening book for the games.")
                .value_name("book.txt")
            ));

    let matches = app.get_matches();
    match matches.subcommand() {
        ("selfplay", _) => {
            for i in 0.. {
                let file_name = format!("games{}_batch0.ptn", i);
                if !Path::new(&file_name).exists() {
                    training::train_perpetually::<5, 69, 91>(
                        i,
                        &VALUE_PARAMS_5S,
                        &POLICY_PARAMS_5S,
                    )
                    .unwrap();
                    break;
                } else {
                    println!("File {} already exists, trying next.", file_name);
                }
            }
        }
        ("selfplay-from-scratch", _) => {
            for i in 0.. {
                let file_name = format!("games{}_batch0.ptn", i);
                if !Path::new(&file_name).exists() {
                    training::train_from_scratch::<5, NUM_VALUE_PARAMS, 91>(i).unwrap();
                    break;
                } else {
                    println!("File {} already exists, trying next.", file_name);
                }
            }
        }
        ("value-from-file", Some(arg)) => {
            let file_name = arg.value_of("file-name").unwrap();
            let value_params =
                training::tune_value_from_file::<5, NUM_VALUE_PARAMS>(file_name).unwrap();
            println!("{:?}", value_params);
        }
        ("both-from-file", Some(arg)) => {
            let value_file_name = arg.value_of("value-file-name").unwrap();
            let policy_file_name = arg.value_of("policy-file-name").unwrap();
            let (value_params, policy_params) = training::tune_value_and_policy_from_file::<
                5,
                NUM_VALUE_PARAMS,
                NUM_POLICY_PARAMS,
            >(value_file_name, policy_file_name)
            .unwrap();
            println!("Value: {:?}", value_params);
            println!("Policy: {:?}", policy_params);
        }
        ("spsa", Some(arg)) => {
            let mut variables = vec![
                spsa::Variable {
                    value: 1.2,
                    delta: 0.20,
                    apply_factor: 0.002,
                },
                spsa::Variable {
                    value: 3500.0,
                    delta: 1000.0,
                    apply_factor: 0.002,
                },
            ];
            spsa::tune::<5>(&mut variables, arg.value_of("book"));
        }
        ("", None) => {
            println!("Error: No subcommand selected. Try the 'help' subcommand for a list.");
            println!("{}", matches.usage());
        }
        _ => unreachable!(),
    }
}
